(load "../Libs/inputoutput.lisp")

(defun request-container-params()
  (let ((result))
    (princ "Enter the container name (press ENTER to stop input): ")
    (let ((container-name) (container-capacity))
      (setq container-name (read-line))
      (when (> (length container-name) 0)
	(setq container-capacity (request-integer-input-with-condition "Enter the container capacity (press ENTER to stop input): " #'(lambda(val)(setq is-greater (> val 0))) "The number should be strictly positive. Please try again"))
	(if (not (null container-capacity))
	    (setq result (list container-name container-capacity)))))
    (return-from request-container-params result)))

(defun main()
  (write-line "In this exercise you need to fill in a water tank of a specific capacity by using multiple containers of different capacities")
  (write-line "All containers are filled with water and the capacities are expressed in liters")
  (write-line "The tank is initially empty")
  (terpri)
  (let ((tank-capacity (request-integer-input-with-condition "Enter the requested tank capacity (press ENTER to quit): " #'(lambda(val)(let ((is-greater)) (setq is-greater (> val 0)))) "The number should be strictly positive. Please try again")))
    (terpri)
    (if (null tank-capacity)
	(write-line "You quit!")
      (let ((containers-hash (make-hash-table :test #'equal))) ; this table is required for avoiding duplicate container names. If the user enters a container with same name the value from previous container is overwritten
	(loop
	 (let ((params (request-container-params)))
	   (if (null params)
	       (return)
	     (setf (gethash (car params) containers-hash) (cadr params)))))
	(terpri)
	(if (= (hash-table-count containers-hash) 0)
	    (write-line "No containers added to input!")
	  (let ((containers (list))) ; all available containers
	    (loop for v being the hash-values of containers-hash using (hash-key k)
		  do (setq containers (cons (list k v) containers)))
	    (sort containers #'> :key #'cadr) ; use greedy algorithm for filling in the tank (start with highest capacity container)
	    (let ((used-containers (list)) (remaining-tank-capacity tank-capacity)) ; used-containers = containers effectively used for filling in the tank
	      (loop for container in containers
		    do (when (<= (cadr container) remaining-tank-capacity)
			 (setq used-containers (cons container used-containers))
			 (setq remaining-tank-capacity (- remaining-tank-capacity (cadr container)))
			 (if (= remaining-tank-capacity 0)
			     (return))))
	      (if (= (length used-containers) 0)
		  (write-line "None of the added containers could be used for filling in the tank as each one has a higher capacity")
		(progn
		  (format t "Total tank capacity: ~d liters~%" tank-capacity)
		  (format t "Filled tank capacity: ~d liters~%" (- tank-capacity remaining-tank-capacity))
		  (format t "~d containers used: ~a~%" (length used-containers) (map 'list #'car used-containers))
		  (if (= remaining-tank-capacity 0)
		      (write-line "The whole tank has been filled! Congrats!")))))))))))

(main)
