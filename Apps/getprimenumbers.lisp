(load "../Libs/mathfunctions.lisp")
(load "../Libs/inputoutput.lisp")
(load "../Libs/parse.lisp")

(defun main()
  (defconstant outputFile "/tmp/primes.txt")
  (setq primes (list))
  (setq left (requestIntInputWithCondition "Enter the left interval margin: " #'(lambda(val)(setq isGreater (> val 1))) "The number should be greater than 1. Please try again"))
  (setq right nil)
  (when (not (null left))
    (setq right (requestIntInputWithCondition "Enter the right interval margin: " #'(lambda(val)(setq isGreater (> val 1))) "The number should be greater than 1. Please try again")))
  (cond ((null right) (write-line "You quit"))
	(t (cond ((> left right) (setq temp left) (setq left right) (setq right temp)))
	   (terpri)
	   (princ "Retrieving prime numbers from interval: ")
	   (cond ((< left right) (format t "[~d; ~d]~%~%" left right) (setq primes (getPrimeNumbers right left)))
		 (t (format t "[~d; ~d]~%~%" firstRelevantPrime right) (setq primes (getPrimeNumbers left)))) ; //equal margins, only one threshold, display prime numbers starting with 2
	   (princ "Done!")
	   (terpri)
	   (terpri)
	   (if (= (length primes) 0)
	       (write-line "There are no prime numbers within this interval!")
	     (progn
	       (with-open-file (stream outputFile :direction :output)
			       (format stream "Found following prime numbers in interval [~d; ~d]: ~%~%" left right)
			       (dotimes (index (length primes))
				 (format stream "Position: ~d~t~t~t~tValue: ~d~%" (+ index 1) (aref primes index)))
			       (format t "~d numbers found~%~%" (length primes))
			       (format t "Please check output file ~d~%" outputFile)))))))

(main)
