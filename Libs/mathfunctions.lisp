(defconstant firstRelevantPrime 2)

; calculates the greatest common divisor by remainder method
(defun gCommonDiv (first second)
  (check-type first integer)
  (check-type second integer)
  (assert (and (/= first 0) (/= second 0)) (first second) "Both arguments should be different from 0")
  (setq result 1)
  (setq divided (abs first)) ; ensure the g.c.d. is positive to avoid any confusion
  (setq divider (abs second))
  (loop
   (setq remainder (rem divided divider))
   (cond ((= remainder 0)(setq result divider)(return))
	 (t (setq divided divider) (setq divider remainder))))
  (return-from gCommonDiv result))

; calculates the greatest common divisor by using prime factors decomposition
(defun gCommonDivPrimeFactors(first second)
  (check-type first integer)
  (check-type second integer)
  (assert (and (/= first 0) (/= second 0)) (first second) "Both arguments should be different from 0")
  (defun getGcdOnePrimeNumber(primeNr notPrimeNr)
    (setq gcdOnePrime 1)
    (if (= (rem notPrimeNr primeNr) 0)
	(setq gcdOnePrime primeNr))
    (return-from getGcdOnePrimeNumber gcdOnePrime))
  (setq gcd 1)
  (setq primeFactorsFirst (getPrimeFactorsForNumber first))
  (setq primeFactorsSecond (getPrimeFactorsForNumber second))
  (cond ((and (not (null primeFactorsFirst)) (not (null primeFactorsSecond)))
	 (loop for primeFactor being each hash-key of primeFactorsFirst ; get common prime factors for both numbers and use the minimum exponent to calculate g.c.d.
	       do (when (not (null (gethash primeFactor primeFactorsSecond)))
		    (setq firstExponent (gethash primeFactor primeFactorsFirst))
		    (setq secondExponent (gethash primeFactor primeFactorsSecond))
		    (setq gcd (* gcd (expt primeFactor (min firstExponent secondExponent)))))))
	((and (not (null primeFactorsFirst)) (null primeFactorsSecond)) (setq gcd (getGcdOnePrimeNumber second first))) ; second number is prime, no need to use prime factors
	((and (not (null primeFactorsSecond)) (null primeFactorsFirst)) (setq gcd (getGcdOnePrimeNumber first second)))) ; first number is prime, no need to use prime factors
  (return-from gCommonDivPrimeFactors gcd)
)

; calculates the least common multiple by using prime factors decomposition
(defun lCommonMulPrimeFactors(first second)
  (check-type first integer)
  (check-type second integer)
  (assert (and (/= first 0) (/= second 0)) (first second) "Both arguments should be different from 0")
  (defun getLcmOnePrimeNumber(primeNr notPrimeNr)
    (setq lcmOnePrime 1)
    (if (= (rem notPrimeNr primeNr) 0)
	(setq lcmOnePrime (abs notPrimeNr))
      (setq lcmOnePrime (* primeNr notPrimeNr)))
    (return-from getLcmOnePrimeNumber lcmOnePrime))
  (setq lcm 1)
  (setq absFirst (abs first)) ; simplify by using absolute values for retrieving l.c.m.
  (setq absSecond (abs second))
  (setq primeFactorsFirst (getPrimeFactorsForNumber absFirst))
  (setq primeFactorsSecond (getPrimeFactorsForNumber absSecond))
  (cond ((and (not (null primeFactorsFirst)) (not (null primeFactorsSecond)))
	 (setq consolidatedPrimeFactors primeFactorsSecond)
	 (loop for primeFactor being each hash-key of primeFactorsFirst ; get common prime factors for both numbers and use the maximum exponent to calculate l.c.m.
	       do
	       (setq resultingExponent (gethash primeFactor primeFactorsFirst))
	       (when (not (null (gethash primeFactor primeFactorsSecond)))
		 (setq resultingExponent (max resultingExponent (gethash primeFactor primeFactorsSecond))))
	       (setf (gethash primeFactor consolidatedPrimeFactors) resultingExponent))
	 (loop for primeFactor being each hash-key of consolidatedPrimeFactors ; calculate l.c.m. based on consolidated prime factors
	       do
	       (setq lcm (* lcm (expt primeFactor (gethash primeFactor consolidatedPrimeFactors))))))
	((and (not (null primeFactorsFirst)) (null primeFactorsSecond) (> absFirst absSecond)) (setq lcm (getLcmOnePrimeNumber absSecond absFirst))) ; second number is prime, no need to use prime factors
	((and (not (null primeFactorsSecond)) (null primeFactorsFirst) (> absSecond absFirst)) (setq lcm (getLcmOnePrimeNumber absFirst absSecond))) ; first number is prime, no need to use prime factors
	((= absFirst absSecond) (setq lcm absFirst))
	(t (setq lcm (* absFirst absSecond))))
  (return-from lCommonMulPrimeFactors lcm)
)

; retrieve prime factors for a number that is not prime
(defun getPrimeFactorsForNumber(number)
  (check-type number integer)
  (assert (/= number 0) (number) "The argument should be different from 0")
  (defun convertPrimesArrayToList(primesArray)
    (setq arrayLength (length primesArray))
    (setq primesList (list))
    (dotimes (index arrayLength)
      (setq primesList (cons (aref primesArray (- (- arrayLength 1) index)) primesList)))
    (return-from convertPrimesArrayToList primesList))
  (setq result nil)
  (setq numberToDivide (abs number))
  (setq primeFactors (make-hash-table)) ; key = prime number, value = number of occurrences within the numberToDivide (power exponent)
  (when (not (= numberToDivide 1))
    (setq primesUntilNumber (convertPrimesArrayToList (getPrimeNumbers numberToDivide)))
    (when (not (member numberToDivide primesUntilNumber))
      (loop for prime in primesUntilNumber
	    do (when (= (rem numberToDivide prime) 0)
		 (setq numberToDivide (floor numberToDivide prime))
		 (setq occurrences 1)
		 (loop
		  (when (/= (rem numberToDivide prime) 0)
		    (return))
		  (setq numberToDivide (floor numberToDivide prime))
		  (incf occurrences 1))
		 (setf (gethash prime primeFactors) occurrences)
		 (when (= numberToDivide 1)
		   (return))))
      (setq result primeFactors)))
    (return-from getPrimeFactorsForNumber result)
)

; get prime numbers in a specific interval (default [2; right])
(defun getPrimeNumbers(right &optional left) ; the search interval has only one mandatory defined margin, namely the right one (left is optional, if not defined than it is presumed 2 - first relevant prime nr)
  (check-type right integer)
  (assert (> right 1) (right) "The given threshold is invalid")
  (when (not (null left))
    (check-type left integer)
    (assert (and (> left 1) (> right left)) (left right) "The given interval is invalid"))
  (setq initialPrimesArrayCapacity (+ (floor right 10) 2)) ; initial allocation of 10% of all numbers belonging to interval (adjust if required), min 2 elements (2, 3) required
  (setq identifiedPrimes (make-array `(,initialPrimesArrayCapacity) :fill-pointer 2 :adjustable t))
  (setf (aref identifiedPrimes 0) 2)                         ; seed the list of prime numbers (first number not to be used for checking as it is the only even one)
  (setf (aref identifiedPrimes 1) 3)
  (do ((currentNrToCheck 5 (+ currentNrToCheck 2)))          ; only check odd numbers for prime-ness
      ((> currentNrToCheck right))
      (dotimes (index (- (fill-pointer identifiedPrimes) 1)) ; exclude 2 from primes number check base
	(setq currentPrimeNr (aref identifiedPrimes (+ index 1)))
	(setq quotient (floor currentNrToCheck currentPrimeNr))
	(setq remainder (rem currentNrToCheck currentPrimeNr))
	(when (= 0 remainder)
	  (return))
	(when (< quotient currentPrimeNr)                    ; add found prime to list of already existing ones (use it in the next iterations for finding new primes)
	  (when (= (fill-pointer identifiedPrimes) (length identifiedPrimes))
	    (setq adjustSize (* 2 (length identifiedPrimes)))
	    (adjust-array identifiedPrimes `(,adjustSize)))
	  (vector-push currentNrToCheck identifiedPrimes)
	  (return))))
  (when (= right 2)                                    ; corner-case, user enters only number 2 as interval (clip everything else)
    (vector-pop identifiedPrimes))
  (setq leftIndex 0)
  (when (not (null left))                              ; adjust array to contain only numbers from interval
    (dotimes (index (fill-pointer identifiedPrimes))
      (if (< (aref identifiedPrimes index) left)
	  (incf leftIndex 1)
	(return))))
  (setq finalNrOfElements (- (fill-pointer identifiedPrimes) leftIndex))
  (setq identifiedPrimesFinal (make-array `(,finalNrOfElements) :displaced-to identifiedPrimes :displaced-index-offset leftIndex))
  (return-from getPrimeNumbers identifiedPrimesFinal))
