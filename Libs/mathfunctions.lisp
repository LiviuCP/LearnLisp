(defconstant firstRelevantPrime 2)

; calculates the greatest common divisor by remainder method
(defun gCommonDiv (first second)
  (check-type first integer)
  (check-type second integer)
  (assert (and (/= first 0) (/= second 0)) (first second) "Both arguments should be different from 0")
  (let ((result 1) (divided (abs first)) (divider (abs second)) (remainder)) ; ensure the g.c.d. is positive to avoid any confusion
    (loop
     (setq remainder (rem divided divider))
     (cond ((= remainder 0)(setq result divider)(return))
	   (t (setq divided divider) (setq divider remainder))))
    (return-from gCommonDiv result)))

; calculates the greatest common divisor by using prime factors decomposition
(defun gCommonDivPrimeFactors(first second)
  (check-type first integer)
  (check-type second integer)
  (assert (and (/= first 0) (/= second 0)) (first second) "Both arguments should be different from 0")
  (defun getGcdOnePrimeNumber(primeNr notPrimeNr)
    (setq gcdOnePrime 1)
    (if (= (rem notPrimeNr primeNr) 0)
	(setq gcdOnePrime primeNr))
    (return-from getGcdOnePrimeNumber gcdOnePrime))
  ; simplify by using absolute values for retrieving l.c.m.
  (let ((gcd 1) (absFirst (abs first)) (absSecond (abs second)))
    (let ((primeFactorsFirst (getPrimeFactorsForNumber absFirst)) (primeFactorsSecond (getPrimeFactorsForNumber absSecond)))
      (cond ((and (not (null primeFactorsFirst)) (not (null primeFactorsSecond)))
	     (loop for primeFactor being each hash-key of primeFactorsFirst ; get common prime factors for both numbers and use the minimum exponent to calculate g.c.d.
		   do (when (not (null (gethash primeFactor primeFactorsSecond)))
			(setq firstExponent (gethash primeFactor primeFactorsFirst))
			(setq secondExponent (gethash primeFactor primeFactorsSecond))
			(setq gcd (* gcd (expt primeFactor (min firstExponent secondExponent)))))))
	    ((and (not (null primeFactorsFirst)) (null primeFactorsSecond) (> absFirst absSecond)) (setq gcd (getGcdOnePrimeNumber absSecond absFirst))) ; second number is prime, no need to use prime factors
	    ((and (not (null primeFactorsSecond)) (null primeFactorsFirst) (> absSecond absFirst)) (setq gcd (getGcdOnePrimeNumber absFirst absSecond))) ; first number is prime, no need to use prime factors
	    ((= absFirst absSecond) (setq gcd absFirst))))
    (return-from gCommonDivPrimeFactors gcd)))

; calculates the least common multiple by using prime factors decomposition
(defun lCommonMulPrimeFactors(first second)
  (check-type first integer)
  (check-type second integer)
  (assert (and (/= first 0) (/= second 0)) (first second) "Both arguments should be different from 0")
  (defun getLcmOnePrimeNumber(primeNr notPrimeNr)
    (setq lcmOnePrime 1)
    (if (= (rem notPrimeNr primeNr) 0)
	(setq lcmOnePrime (abs notPrimeNr))
      (setq lcmOnePrime (* primeNr notPrimeNr)))
    (return-from getLcmOnePrimeNumber lcmOnePrime))
  (let ((lcm 1) (absFirst (abs first)) (absSecond (abs second)))
    (let ((primeFactorsFirst (getPrimeFactorsForNumber absFirst)) (primeFactorsSecond (getPrimeFactorsForNumber absSecond)))
      (cond ((and (not (null primeFactorsFirst)) (not (null primeFactorsSecond)))
	     (setq consolidatedPrimeFactors primeFactorsSecond)
	     (loop for primeFactor being each hash-key of primeFactorsFirst ; get common prime factors for both numbers and use the maximum exponent to calculate l.c.m.
		   do
		   (setq resultingExponent (gethash primeFactor primeFactorsFirst))
		   (when (not (null (gethash primeFactor primeFactorsSecond)))
		     (setq resultingExponent (max resultingExponent (gethash primeFactor primeFactorsSecond))))
		   (setf (gethash primeFactor consolidatedPrimeFactors) resultingExponent))
	     (loop for primeFactor being each hash-key of consolidatedPrimeFactors ; calculate l.c.m. based on consolidated prime factors
		   do
		   (setq lcm (* lcm (expt primeFactor (gethash primeFactor consolidatedPrimeFactors))))))
	    ((and (not (null primeFactorsFirst)) (null primeFactorsSecond) (> absFirst absSecond)) (setq lcm (getLcmOnePrimeNumber absSecond absFirst))) ; second number is prime, no need to use prime factors
	    ((and (not (null primeFactorsSecond)) (null primeFactorsFirst) (> absSecond absFirst)) (setq lcm (getLcmOnePrimeNumber absFirst absSecond))) ; first number is prime, no need to use prime factors
	    ((= absFirst absSecond) (setq lcm absFirst))
	    (t (setq lcm (* absFirst absSecond)))))
    (return-from lCommonMulPrimeFactors lcm)))

; retrieve prime factors for a number that is not prime
(defun getPrimeFactorsForNumber(number)
  (check-type number integer)
  (assert (/= number 0) (number) "The argument should be different from 0")
  (defun convertPrimesArrayToList(primesArray)
    (setq arrayLength (length primesArray))
    (setq primesList (list))
    (dotimes (index arrayLength)
      (setq primesList (cons (aref primesArray (- (- arrayLength 1) index)) primesList)))
    (return-from convertPrimesArrayToList primesList))
  (setq result nil)
  (setq numberToDivide (abs number))
  (setq primeFactors (make-hash-table)) ; key = prime number, value = number of occurrences within the numberToDivide (power exponent)
  (when (not (= numberToDivide 1))
    (setq primesUntilNumber (convertPrimesArrayToList (getPrimeNumbers numberToDivide)))
    (when (not (member numberToDivide primesUntilNumber))
      (loop for prime in primesUntilNumber
	    do (when (= (rem numberToDivide prime) 0)
		 (setq numberToDivide (floor numberToDivide prime))
		 (setq occurrences 1)
		 (loop
		  (when (/= (rem numberToDivide prime) 0)
		    (return))
		  (setq numberToDivide (floor numberToDivide prime))
		  (incf occurrences 1))
		 (setf (gethash prime primeFactors) occurrences)
		 (when (= numberToDivide 1)
		   (return))))
      (setq result primeFactors)))
    (return-from getPrimeFactorsForNumber result)
)

; get prime numbers in a specific interval (default [2; right])
(defun getPrimeNumbers(right &optional left) ; the search interval has only one mandatory defined margin, namely the right one (left is optional, if not defined than it is presumed 2 - first relevant prime nr)
  (check-type right integer)
  (assert (> right 1) (right) "The given threshold is invalid")
  (when (not (null left))
    (check-type left integer)
    (assert (and (> left 1) (> right left)) (left right) "The given interval is invalid"))
  (setq initialPrimesArrayCapacity (+ (floor right 10) 2)) ; initial allocation of 10% of all numbers belonging to interval (adjust if required), min 2 elements (2, 3) required
  (setq identifiedPrimes (make-array `(,initialPrimesArrayCapacity) :fill-pointer 2 :adjustable t))
  (setf (aref identifiedPrimes 0) 2)                         ; seed the list of prime numbers (first number not to be used for checking as it is the only even one)
  (setf (aref identifiedPrimes 1) 3)
  (do ((currentNrToCheck 5 (+ currentNrToCheck 2)))          ; only check odd numbers for prime-ness
      ((> currentNrToCheck right))
      (dotimes (index (- (fill-pointer identifiedPrimes) 1)) ; exclude 2 from primes number check base
	(setq currentPrimeNr (aref identifiedPrimes (+ index 1)))
	(setq quotient (floor currentNrToCheck currentPrimeNr))
	(setq remainder (rem currentNrToCheck currentPrimeNr))
	(when (= 0 remainder)
	  (return))
	(when (< quotient currentPrimeNr)                    ; add found prime to list of already existing ones (use it in the next iterations for finding new primes)
	  (when (= (fill-pointer identifiedPrimes) (length identifiedPrimes))
	    (setq adjustSize (* 2 (length identifiedPrimes)))
	    (adjust-array identifiedPrimes `(,adjustSize)))
	  (vector-push currentNrToCheck identifiedPrimes)
	  (return))))
  (when (= right 2)                                    ; corner-case, user enters only number 2 as interval (clip everything else)
    (vector-pop identifiedPrimes))
  (setq leftIndex 0)
  (when (not (null left))                              ; adjust array to contain only numbers from interval
    (dotimes (index (fill-pointer identifiedPrimes))
      (if (< (aref identifiedPrimes index) left)
	  (incf leftIndex 1)
	(return))))
  (setq finalNrOfElements (- (fill-pointer identifiedPrimes) leftIndex))
  (setq identifiedPrimesFinal (make-array `(,finalNrOfElements) :displaced-to identifiedPrimes :displaced-index-offset leftIndex))
  (return-from getPrimeNumbers identifiedPrimesFinal))

; calculate a Fibonacci-like matrix: on each row, column and diagonal each number is the sum of the previous two numbers (initial numbers can be provided by user)
(defun getFibonacciMatrix(order &optional initialValues) ; initialValues should be a list of four integer elements that are (in this order): (0, 0), (0, 1), (1, 0), (1, 1)
  (check-type order integer)
  (assert (> order 0) (order) "The matrix order is invalid")
  (when (not (null initialValues))
    (check-type initialValues list)
    (assert (>= (length initialValues) 4) (initialValues) "The initial values list contains less than the required four elements")
    (dotimes (index 4)
      (check-type (nth index initialValues) integer))
    (assert (>= (nth 0 initialValues) 0) (initialValues) "Negative initial value identified")
    (dotimes (index 3)
      (assert (> (nth (+ index 1) initialValues) (nth 0 initialValues)) (index initialValues) "First matrix element (0, 0) is not smaller than each of the other three: (0, 1), (1, 0), (1, 1)")))
  (let ((fibMatrix (make-array `(,order ,order))))
    (if (not (null initialValues))
	(setf (aref fibMatrix 0 0) (nth 0 initialValues))
      (setf (aref fibMatrix 0 0) 0))
    (when (> order 1)
      (cond ((not (null initialValues))
	     (setf (aref fibMatrix 0 1) (nth 1 initialValues))
	     (setf (aref fibMatrix 1 0) (nth 2 initialValues))
	     (setf (aref fibMatrix 1 1) (nth 3 initialValues)))
	    (t
	     (setf (aref fibMatrix 0 1) 1)
	     (setf (aref fibMatrix 1 0) 1)
	     (setf (aref fibMatrix 1 1) 1))))
    (when (> order 2)
      (loop for diagIndex from 2 to (- order 1)
	    do
	    (let ((prevDiagIndex (- diagIndex 1)) (secPrevDiagIndex (- diagIndex 2)))
	      (setf (aref fibMatrix diagIndex diagIndex) (+ (aref fibMatrix secPrevDiagIndex secPrevDiagIndex) (aref fibMatrix prevDiagIndex prevDiagIndex)))
	      (dotimes (rowIndex diagIndex)
		(setf (aref fibMatrix rowIndex diagIndex) (+ (aref fibMatrix rowIndex secPrevDiagIndex) (aref fibMatrix rowIndex prevDiagIndex))))
	      (dotimes (colIndex diagIndex)
		(setf (aref fibMatrix diagIndex colIndex) (+ (aref fibMatrix secPrevDiagIndex colIndex) (aref fibMatrix prevDiagIndex colIndex)))))))
    (return-from getFibonacciMatrix fibMatrix)))
