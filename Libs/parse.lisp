(defconstant digits (list #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

(defun getDigitCharToNumberHash()
    (let ((digitHash (make-hash-table)))
      (setf (gethash #\0 digitHash) 0)
      (setf (gethash #\1 digitHash) 1)
      (setf (gethash #\2 digitHash) 2)
      (setf (gethash #\3 digitHash) 3)
      (setf (gethash #\4 digitHash) 4)
      (setf (gethash #\5 digitHash) 5)
      (setf (gethash #\6 digitHash) 6)
      (setf (gethash #\7 digitHash) 7)
      (setf (gethash #\8 digitHash) 8)
      (setf (gethash #\9 digitHash) 9)
      (return-from getDigitCharToNumberHash digitHash)))

; own implementation of parse-integer
(defun convertStringToInt(str)
  (defun isStringConvertibleToInteger(str)
    (let ((isInteger t))
      (cond ((= (length str) 0) (setq isInteger nil))                                             ; case 1: no characters
	    ((and (= (length str) 1) (not (member (aref str 0) digits))) (setq isInteger nil))    ; case 2: single character, should be numeric
	    ((> (length str) 1)                                                                   ; case 3: more than one character, only first character can be '-' (all others should be numeric)
	     (if (not (or (member (aref str 0) digits) (char-equal (aref str 0) #\-)))
		 (setq isInteger nil)
	       (loop for index from 1 to (- (length str) 1)
		     do (when (not (member (aref str index) digits))
			  (setq isInteger nil)
			  (return))))))
      (return-from isStringConvertibleToInteger isInteger)))
  (check-type str string)
  (let ((intResult nil))
    (when (isStringConvertibleToInteger str)
      (setq intResult 0)
      (let ((startPos 0) (charToNumberHash (getDigitCharToNumberHash)))
	(when (char-equal (aref str 0) #\-)
	  (setq startPos 1))
	(loop for index from startPos to (- (length str) 1)
	      do
	      (setq intDigitExponent (- (length str) 1 index))
	      (setq intDigit (gethash (aref str index) charToNumberHash))
	      (setq intResult (+ intResult (* intDigit (expt 10 intDigitExponent)))))
	(if (= startPos 1)
	    (setq intResult (- 0 intResult)))))
    (return-from convertStringToInt intResult)))

(defun convertStringToFloat(str)
  ; state-machine with states: 0 - Init, 1 - SignAdded, 2 - LeftDigitsAdded, 3 - CommaAdded, 4 - RightDigitsAdded, 5 - Invalid (possibly to be revised as use of "magic numbers" is not the best solution)
  ; for fraction we have the additional states: 6 - SlashAdded, 7 - SecondSignAdded
  (check-type str string)
  (let ((commaPosition -1) (slashPosition -1) (isNegative) (isDivisionByZero nil) (result))
    (defun isStringConvertibleToFloat(str)
      (let ((state 0))
	(cond ((= (length str) 0) (setq state 5))
	      ((char-equal (aref str 0) #\-) (setq state 1) (setq isNegative t))
	      ((member (aref str 0) digits) (setq state 2))
	      (t (setq state 5)))
	(when (/= state 5)
	  (dotimes (checkedCharNr (- (length str) 1))
	    (let ((index (+ checkedCharNr 1)))
	      (case state
		    (1 (cond ((member (aref str index) digits) (setq state 2))
			     (t (setq state 5))))
		    (2 (cond ((char-equal (aref str index) #\.) (setq state 3) (setq commaPosition index))
			     ((char-equal (aref str index) #\/) (setq state 6) (setq slashPosition index))
			     ((not (member (aref str index) digits)) (setq state 5))))
		    (3 (cond ((member (aref str index) digits) (setq state 4))
			     (t (setq state 5))))
		    (4 (cond ((not (member (aref str index) digits)) (setq state 5))))
		    (5 (return))
		    (6 (cond ((member (aref str index) digits) (setq state 4))
			     ((char-equal (aref str index) #\-) (setq state 7) (setq isNegative (not isNegative)))
			     (t (setq state 5))))
		    (7 (cond ((member (aref str index) digits) (setq state 4))
			     (t (setq state 5))))))))
	; if the string is a fraction it should not be convertible if a division by zero is detected
	(when (and (/= slashPosition -1) (= state 4))
	    (let ((denNumString) (denNumStartPosition (+ slashPosition 1))) ; denominator numeric (sub)string and (sub)string start index
	      (when (char-equal (aref str denNumStartPosition) #\-)
		(incf denNumStartPosition 1))
	      (setq denNumString (string-left-trim "0" (subseq str denNumStartPosition)))
	      (if (= (length denNumString) 0)
		  (setq isDivisionByZero t))))
	(return-from isStringConvertibleToFloat (or (= state 2) (and (= state 4) (not isDivisionByZero)))))) ; the string should be an integer or a float/fraction
    (when (isStringConvertibleToFloat str)
      (setq result 0.0)
      (let ((leftNumberString) (rightNumberString))
	(cond ((/= commaPosition -1) ; case 1: decimal string, comma available
	       (setq rightNumberString (subseq str (+ commaPosition 1)))
	       (if (char-equal (aref str 0) #\-)
		   (setq leftNumberString (subseq str 1 commaPosition))
		 (setq leftNumberString (subseq str 0 commaPosition))))
	      ((/= slashPosition -1) ; case 2: fraction string, slash available
	       (if (char-equal (aref str 0) #\-)
		   (setq leftNumberString (subseq str 1 slashPosition))
		 (setq leftNumberString (subseq str 0 slashPosition)))
	       (if (char-equal (aref str (+ slashPosition 1)) #\-)
		   (setq rightNumberString (subseq str (+ slashPosition 2)))
		 (setq rightNumberString (subseq str (+ slashPosition 1)))))
	      ((not (null isNegative)) (setq leftNumberString (subseq str 1)))
	      (t (setq leftNumberString str))) ; case 3: no comma/slash, pure integer
	(let ((charToNumberHash (getDigitCharToNumberHash)))
	  (when (not (null rightNumberString)) ; optional: get right side number (decimal part / denominator)
	    (if (/= commaPosition -1) ; decimal part scenario
		(loop for index from 0 to (- (length rightNumberString) 1)
		      do
		      (let ((decimalDigitExponent (+ 1 index)) (rightNumberDigit (gethash (aref rightNumberString index) charToNumberHash)))
			(setq result (+ result (* rightNumberDigit (expt 0.1 decimalDigitExponent))))))
	      (let ((denominator 0)) ; denominator scenario
		(loop for index from 0 to (- (length rightNumberString) 1)
		      do
		      (let ((denomDigitExponent (- (length rightNumberString) 1 index)) (rightNumberDigit (gethash (aref rightNumberString index) charToNumberHash)))
			(setq denominator (+ denominator (* rightNumberDigit (expt 10 denomDigitExponent))))))
		(setq result denominator))))
	  (let ((intPart 0))
	    (loop for index from 0 to (- (length leftNumberString) 1) ; mandatory: get integer part of the number
		  do
		  (let ((intDigitExponent (- (length leftNumberString) 1 index)) (intPartDigit (gethash (aref leftNumberString index) charToNumberHash))) 
		    (setq intPart (+ intPart (* intPartDigit (expt 10 intDigitExponent))))))
	    (if (/= slashPosition -1)
		(setq result (/ (* 1.0 intPart) result))
	      (setq result (+ result intPart))))))
      (if (not (null isNegative)) ; finally add negative sign (if applicable)
	  (setq result (- 0 result))))
    (return-from convertStringToFloat result)))
