; performs a simple "shuffle" of the array by ordering the elements: a[0] <= a[1] >= a[2] <= a[3] ... or a[0] >= a[1] <= a[2] >= a[3] ...
(defun counterSort(inputArray &optional initiallyDecreasing)
  (check-type inputArray array)
  (dotimes (index (length inputArray))
    (check-type (aref inputArray index) (or integer float rational)))
  (let ((increasingOrderRequired (not initiallyDecreasing)))
    (dotimes (index (- (length inputArray) 1))
      (when (or (and increasingOrderRequired (> (aref inputArray index) (aref inputArray (+ index 1)))) (and (not increasingOrderRequired) (< (aref inputArray index) (aref inputArray (+ index 1)))))
	  (let ((temp (aref inputArray index)))
	    (setf (aref inputArray index) (aref inputArray (+ index 1)))
	    (setf (aref inputArray (+ index 1)) temp)))
      (setq increasingOrderRequired (not increasingOrderRequired))))) ; change ordering type for each step (increasing/decreasing)

(defun bubbleSort(inputArray &optional sortKey)
  (check-type inputArray array)
  (dotimes (index (length inputArray))
    (check-type (aref inputArray index) (or integer float rational)))
  (if (not (null sortKey))
      (check-type sortKey function)
    (setq sortKey (lambda(a b)(let ((result))(setq result (<= a b))))))
  (loop
   (let ((sortingPerformed))
     (dotimes (index (- (length inputArray) 1))
       (when (not (funcall sortKey (aref inputArray index) (aref inputArray (+ index 1))))
	 (let ((temp (aref inputArray index)))
	   (setf (aref inputArray index) (aref inputArray (+ index 1)))
	   (setf (aref inputArray (+ index 1)) temp)
	   (setq sortingPerformed t))))
     (when (not sortingPerformed) ; stop when no item swap performed along the iteration
       (return)))))

(defun mergeSort(inputArray &optional sortKey)
  (defun doMergeSort(inputArray auxArray startIndex endIndex sortKey)
    (when (/= startIndex endIndex)
      (let ((midIndex (floor (+ startIndex endIndex) 2)) (firstIndex) (secondIndex) (writeIndex))
	(doMergeSort inputArray auxArray startIndex midIndex sortKey)
	(doMergeSort inputArray auxArray (+ midIndex 1) endIndex sortKey)
	(setq firstIndex startIndex)
	(setq secondIndex  (+ midIndex 1))
	(setq writeIndex startIndex)
	(loop
	 (if (or (> firstIndex midIndex) (> secondIndex endIndex))
	     (return))
	 (cond ((not (funcall sortKey (aref inputArray secondIndex) (aref inputArray firstIndex))) (setf (aref auxArray writeIndex) (aref inputArray firstIndex)) (incf firstIndex 1))
	       (t (setf (aref auxArray writeIndex) (aref inputArray secondIndex)) (incf secondIndex 1)))
	 (incf writeIndex 1))
	(if (<= firstIndex midIndex)
	    (loop
	     (when (> writeIndex endIndex)
		 (return))
	     (setf (aref auxArray writeIndex) (aref inputArray firstIndex))
	     (incf firstIndex 1)
	     (incf writeIndex 1))
	  (if (<= secondIndex endIndex)
	      (loop
	       (when (> writeIndex endIndex)
		   (return))
	       (setf (aref auxArray writeIndex) (aref inputArray secondIndex))
	       (incf secondIndex 1)
	       (incf writeIndex 1))))
	(loop for firstIndex from startIndex to endIndex
	      do (setf (aref inputArray firstIndex) (aref auxArray firstIndex))))))
  (check-type inputArray array)
  (dotimes (index (length inputArray))
    (check-type (aref inputArray index) (or integer float rational)))
  (if (not (null sortKey))
      (check-type sortKey function)
    (setq sortKey (lambda(a b)(let ((result))(setq result (<= a b))))))
  (let ((nrOfElements (length inputArray)))
    (when (> (length inputArray) 0)
      (let ((auxArray (make-array `(,(length inputArray)))))
	(dotimes (index nrOfElements)
	  (setf (aref auxArray index) (aref inputArray index)))
	(doMergeSort inputArray auxArray 0 (- nrOfElements 1) sortKey)))))
